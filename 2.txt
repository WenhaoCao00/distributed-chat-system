1. client单独开一个线程周期性拿到所有的server address, 并且需要一个leader（这个Leader是client.py中find_leader这个函数寻找的）
2. 当发送消息的client发现leader长时间没有回复ACK，则通知-1个server address开始leader election. 每次保存一句话，当收到ACK前不能继续聊天，如果收不到ACK，等到第一步线程leader非空的时候再发送Last_word
3. 每次client发送消息都会发给Leader，并且leader每次都会回复ACK表示正常，如果没有则进行第二步
4. 


chatgpt
客户端发送消息时处理 Leader 超时：

保存未确认的消息：确保在发送消息时，未收到 ACK 前将消息保存，以便重新发送。
超时处理：如果在设定时间内没有收到 ACK，启动重新选举，并在选举结束后重新发送消息。

发送消息：客户端发送消息给当前的 Leader，等待 ACK。
接收 ACK：如果收到 ACK，继续处理下一条消息；如果超时未收到 ACK，启动选举流程。


!!!
详细步骤：
客户端周期性获取服务器地址和 Leader：

启动一个线程，定期获取服务器地址列表。
在获取服务器地址后，调用 find_leader 函数寻找当前的 Leader。
客户端发送消息并处理超时：

客户端发送消息给当前的 Leader，设置超时时间等待 ACK。
如果在设定时间内未收到 ACK，启动重新选举，并在选举结束后重新发送未确认的消息。
客户端处理选举结果并更新 Leader：

选举过程中，客户端和服务器协作选出新的 Leader。
在选举结束后，客户端更新本地的 Leader 信息，并重新发送未确认的消息。
逻辑总结：
定期获取服务器地址：确保客户端始终获取最新的服务器列表和 Leader 信息。
消息发送和 ACK 处理：客户端在发送消息后等待 ACK，如果超时未收到，则启动选举。
选举过程和 Leader 更新：确保在 Leader 失效时能迅速选出新的 Leader，并恢复正常的消息处理。